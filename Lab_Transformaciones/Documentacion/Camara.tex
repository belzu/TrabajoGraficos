\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{color}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\makeatletter\makeatother
\usepackage{listings}

% Paketea konfiguratu behar dugu C lengoaiarekin erabiltzeko:
\definecolor{darkgreen}{rgb}{0,0.5,0}
\definecolor{lightgray}{rgb}{0.95,0.95,0.95}
\definecolor{gray}{rgb}{0.65,0.65,0.65}
\lstset{language=C,
		basicstyle=\scriptsize\ttfamily,
		keywordstyle=\color{darkgreen}\bfseries,
		identifierstyle=\color{blue},
		commentstyle=\color{gray}, 
		stringstyle=\ttfamily,
		showstringspaces=false,
		tabsize=2,
		backgroundcolor=\color{lightgray}}


\begin{document}

\title{\begin{center}
\resizebox*{0.50\textwidth}{0.15 \textheight}{
\includegraphics{ehu-pdf.pdf}
} 
\end{center}
\vspace{1cm}
Control de camara y iluminación en OpenGL}

\author{Ignacio Belzunegui y Aitor Domec}

\maketitle

\section{Objetivos de nuestra aplicación}

Nuestra aplicación tiene que ser capaz de controlar una camara y la iluminación.
Tienen que existir varias cámaras, debemos de poder ver lo que un objeto, entrar en modo análisis/vuelo, modificar el volumen de vision, trasladar/rotar la cámara y cambiar el tipo de proyección entre modo paralelo o perspectiva.\newline
Hemos dividido este trabajo en dos partes, camara y iluminacion (cada una tendrá sus propios sub-apartados).
\begin{enumerate}
\item \textbf{Camara.}
\begin{enumerate}
\item \textbf{Camara / Estructura de la camara.}
\begin{enumerate}
\item \textbf{Estructura.}
\item \textbf{Cambio de camara.}
\item \textbf{Camara del objeto.}
\end{enumerate}
\item \textbf{Modificaciones sobre la camara.}
\begin{enumerate}
\item \textbf{Transformaciones.}
\begin{enumerate}
\item \textbf{Cambio volumen de vision.}
\item \textbf{Modo analisis / Modo vuelo.}
\item \textbf{Rotacion.}
\item \textbf{Traslacion.}
\end{enumerate}
\item \textbf{Cambio de tipo de proyeccion.}
\end{enumerate}
\end{enumerate}
\item \textbf{Iluminación.}
\begin{enumerate}
\item \textbf{Prueba}
\end{enumerate}
\end{enumerate}


\section{Manual de usuario}

Para compilar el programa debemos de compilar main.c, display.c, io.c y load\_obj\_joseba.c por supuesto teniendo en cuenta que usamos OpenGL y librerias de lglu, el comando para compilar es el siguiente:\newline
\textit{gcc main.c  display.c io.c load\_obj\_joseba.c -lGL -lGLU -lglut -lm}\newline
Este comando generará el ejecutable \textbf{a.out}. \newline
Para ejecutar el ejecut\newline \textit{ ./a.out }\newline
Una vez ejecutado el programa el usuario verá en el terminal la guía de ayuda que explica los comandos existentes y sus utilidades. También verá una ventana emergente donde se visualizarán todos los objetos y donde realizará las transformaciones pertinentes. \newline
Primero se deberá de cargar un objeto, de lo contrario no nos permitirá realizar ninguna operación. Para cargar un objeto deberá de escribir el path al objeto, dándole a la "f" antes; nosotros recomendamos el uso del siguiente comando para ahorrarnos el tener que escribir el path cada vez que cargamos un objeto: \textbf{cp objects/abioia.obj ./a} donde objects/abioia.obj es el path al objeto deseado. De esta forma para cargar un objeto bastará con escribir únicamente "a".\newline
Una vez cargado el objeto tenemos acceso completo a todos los comandos, de forma predefinida los cambios se realizarán respecto al objeto y comenzará con el modo de rotación activado, pero esto podrá ser cambiado a voluntad en cualquier momento. Si deseamos utilizar la camara podremos acceder a sus comandos si pulsamos la tecla 'k', del mismo modo si deaseamos activar/desactivar la iluminaciónn deberemos de pulsar la tecla 'f9'.\newline
Los comandos permitidos son los siguientes:
\begin{enumerate}
\item "?"		 		 Visualizar ayuda.
\item "ESC"		 		 Salir del programa.
\item "f / F"				 Cargar un objeto.
\item "TAB"		 		 Cambiar la seleccion de un objeto cargado.
\item "DEL"				 Borrar el objeto seleccionado.
\item "CTRL + -"		 Aumentar el zoom.
\item "CTRL + +"		 Reducir el zoom.
\item "l / L"		 	 Activar transformaciones respecto al objeto.
\item "g / G"		 	 Activar transformaciones respecto al mundo.
\item "m / M"		 	 Activar la traslacion.
\item "b / B"			 Activar la rotacion.
\item "t / T"		 	 Activar el escalado.
\end{enumerate}
Para realizar las tranformaciones deseadas debemos de pulsar las flechas del teclado u las teclas 'PageUp' o 'PageDown'.\newline

\section{Cambios realizados}

\begin{enumerate}
\item \textbf{Camara.}\newline

\begin{enumerate}
\item \textbf{Estructura.}
Nuestra camara va a ser una pila doble que contendrá, una lista de matrices, un identificador y varios parametros que nos serviran para modificar el volumen de visión de la misma.\newline
Cada cámara apunta a la camara anterior y a la siguiente, creando asi un circuito cerrado.\newline
\begin{lstlisting}
typedef struct camara_l{
    int numero;							      /*Identificador de la camara*/
    GLdouble left;                /**/
    GLdouble right;               /**/
    GLdouble bottom;              /**/
    GLdouble top;                 /**/
    GLdouble near;                /*Desde como de cerca vemos*/
	  GLdouble far;                 /*Como de lejos llegamos a ver*/

  	GLdouble ortho_x_min;				  /* Parametros usados*/
  	GLdouble ortho_x_max;				  /* para el modo     */
  	GLdouble ortho_y_min;				  /* de proyeccion    */
  	GLdouble ortho_y_max;				  /* ortogonal        */

	  struct matrix_l *matrix;      /*Lista de matrices*/
    struct camara_l *next;        /*Siguiente camara */
    struct camara_l *previous;    /*Camara anterior */
} camara_l;
\end{lstlisting}

\item \textbf{Cambio de camara.}
Existen 4 camaras creadas en nuestro proyecto. Si activamos el modo camara (pulsando las tecla 'k' o 'K') y pulsamos la 'c' cambiaremos de la cámara actual a la siguiente en la lista; se nos indicará por terminal en cual nos encontramos.\newline
Cabe destacar que la camara inicial es simplemente la de identidad y que comenzaremos viendo todo desde un modo de perspectica ortogonal, es decir, en \textbf{paralelo}. Estos significa que todos los objeto se verán como si se encontraran a la misma distancia, independientemente de su posición real.\newline
Para conseguir el efecto de cambiar de cámara, simplemente guardaremos la cámara actual en 'camara\_auxiliar' y haremos que la cámara principal ('camaraG') apunte a la siguiente en la lista.
Si queremos volver desde la cámara del objeto a las cámaras predefinidas en el aplicación es importante tener un "backup" de la camara global en el momento en el que se ha seleccionado la cámara del objeto. Por eso mismo, hemos definido una \textit{matrix\_l} llamada camara\_auxiliar (nótese que es una variable global) que tiene como objetivo guardar el valor de la camara global cuando se ha seleccionado la cámara del objeto.
\begin{lstlisting}
case 'c'://Cambiamos de camara
	if(camaraG==_selected_object->camara){
		camaraG=camara_auxiliar;
	}     
	else{
		camara_auxiliar=camaraG;
		camaraG=camaraG->next;
	}
    printf("Usted acaba de cambiar a 
    la camara: %i\n",camaraG->numero);
break;
\end{lstlisting}


\item \textbf{Camara del objeto.}
Si pulsamos la tecla 'C' la camara actual se trasladará al objeto, viendo asi lo que el objeto "ve". Una vez activado el modo de cámara del objeto no seremos capaces de modificar la cámara, si queremos cambiar nuestro punto de vista deberemos de transformar el objeto selecionado.\newline
'modog' es una variable que dice si están activadas las transformaciones en los objetos (modog=0), cámara (modog=1) o iluminación (modog=2). 'modoCamara' indica si la cámara se ha colocado encima del objeto o no (Activado modoCamara=1, desactivado modoCamara=0), ya que si está activado no podremos modificar la cámara.\newline
Cabe mencionar que si queremos trasladarnos o rotar, tendremos que activar el modo objeto y trasladarnos o rotar desde ahí.
Eventualmente podremos observar que el objeto y la cámara se mueven a la par. Para desactivar el modo cámara del objeto debemos activar el modo cámara pulsando K y pulsando C otra vez.

\begin{lstlisting}
case 'C':
	if(modog==1) {
		if(modoCamara==0){
  		  modoCamara=1;
      	printf("Usted acaba de cambiar a la camara del objeto\n");
    	}
    	else {
    		modoCamara=0;
    		printf("Usted acaba de desactivar la camara del objeto\n");
    	}
	}
	else {
		printf("No esta activado el modo de camara\n");
	}
break;
\end{lstlisting}
Una vez activado el modoCamara deberemos de tener en cuenta que cada vez que se modifique el objeto deberemos de modificar también la cámara. Para ello hemos creado una función llamada 'camera\_update()' que, una vez activado el modoCamara, se asegurará de actualizar la matriz de la cámara cada vez que se realize una transformación en el objeto. Cada vez que llamamos a 'camera\_update' realizaremos un gluLookAt con los siguientes valores: Eye=Posición del objeto, Center=Posición del objeto-Vector Z del objeto, Up= Vector Y del objeto\newline.

\begin{lstlisting}
void camera_update() {
	if(modoCamara==1) {
		glLoadIdentity();
		gluLookAt(_selected_object->matrix->matrix[12],
		_selected_object->matrix->matrix[13],
		_selected_object->matrix->matrix[14],
    _selected_object->matrix->matrix[12]-_selected_object->matrix->matrix[8],
    _selected_object->matrix->matrix[13]-_selected_object->matrix->matrix[9],
    _selected_object->matrix->matrix[14]-_selected_object->matrix->matrix[10],
    _selected_object->matrix->matrix[4],
    _selected_object->matrix->matrix[5],
    _selected_object->matrix->matrix[6]);
		glGetDoublev(GL_MODELVIEW_MATRIX,camaraG->matrix->matrix);

	}
}
\end{lstlisting}
Esta función es llamada cada vez que pulsamos una tecla, por lo que va a aparecer al final de tanto la función de teclado normal como la especial (encargada de leer las flechas).
\end{enumerate}




\item \textbf{Modificaciones sobre la cámara.}\newline
\begin{enumerate}
\item \textbf{Transformaciones.}

\begin{enumerate}
\item \textbf{Cambio volumen de visión.}
Si la cámara está activada (tecla 'k') y pulsamos la 't/T' vamos a activar el cambio en volumen de visión.\newline
Dentro de cada cámara guardamos los valores left, right, top, bottom, near y far. Los dos últimos son los encargados de decir como de lejos vemos (far) y desde como de cerca empezamos a ver (near). Los otros cuatro valores son los encargados de especificar la 'ventana' desde la que vemos en el modo perspectiva, si los alteramos veremos el escenario deformado. Es decir, nos muestran las "dimensiones" de nuestro volumen de visión.\newline
Visualizaremos la implementación del cambio de volumen de visión mediante el código implementado en el botón UP.
\begin{lstlisting}
        case GLUT_KEY_PAGE_UP:
        	if(modoV == 0){//Modo vuelo
                if(modo==1) {
					(...)
                }
                if(modo==2) {
   					(...)
                }
               	if(modo==3) {
               		if(modog==0){
						(...)
                    }
                    if (modog==1)
                     {
                		camaraG->near=camaraG->near*1.1;
                		camaraG->far=camaraG->far*1.1;
                     } 
                }
             }
             else {//Modo analisis
             	if(modo==2){
             		(...)
             	}
             	if(modo==1){
             		(...)
             	}
             }
                (...)
        break;
\end{lstlisting}

Los parámetros near y far aumentan en un 10\% (multiplicamos por 1.1) cuando le damos al botón UP y disminuyen un 10\% (multiplicamos por 0.9) cuando es pulsado el botón DOWN, y los parámetros right y left aumentan un 10\% cuando RIGHT es pulsado y disminuyen un 10\% cuando LEFT es pulsado. 

\item \textbf{Modo Análisis/Vuelo.}
El modo vuelo nos permite "volar" por el escenario; la cámara podrá ser movida libremente por el mundo dependiendo de lo que queramos hacer (como trasladarnos o rotar).

El modo análisis nos permite "analizar" (como indica su nombre) un objeto, situándolo en el centro de la cámara y permitiéndonos verlo desde cualquier ángulo a cualquier distancia.
La variable modoV define el modo en el que nos encontramos; modoV = 0 modo VUELO y modoV = 1 modo ANÁLISIS.
Cambiaremos entre modo vuelo y modo análisis pulsando la tecla G/g. Por defecto estará activado el modo vuelo.


\begin

\item \textbf{Rotación.}

La cámara puede rotar sobre si misma en el MODO VUELO (modoV = 0) y alrededor de un objeto concreto en el MODO ANÁLISIS (modoV=1).
\begin{lstlisting}
void rotate(float angle,float a, float b, float c)
{ 
    //Hacemos el cambio respecto al objeto
    if(_selected_object!=NULL) {
        if(modog==0) {//Sobre el objeto
            if(modo2==0){
				(...)
            }
        //Hacemos el cambio respecto al mundo
            else {
				(...)
            }   
        }
        else {//Cambio respecto a la camara
            if (modoV==0)//Modo vuelo
            {
            	glMatrixMode(GL_MODELVIEW);
	            glLoadIdentity();
	            glRotatef(angle,a, b, c);
	            glMatrixMode(GL_MODELVIEW);
	            glMultMatrixd(camaraG->matrix->matrix);
	            guardar_estado();
	            representar_matriz();
            }
            else{//modo analisis
            
            	matrix_l *matrizaux;
        		matrizaux = (matrix_l *) 
        		malloc(sizeof (matrix_l));
        		
        		//Matriz inversa de la MCSR
        		matrizaux->matrix[0] = 
        		camaraG->matrix->matrix[0];
				matrizaux->matrix[1] = 
				camaraG->matrix->matrix[4];
				matrizaux->matrix[2] = 
				camaraG->matrix->matrix[8];	
				matrizaux->matrix[3] = 0.0;

	
				matrizaux->matrix[4] = 
				camaraG->matrix->matrix[1];
				matrizaux->matrix[5] = 
				camaraG->matrix->matrix[5];	
				matrizaux->matrix[6] = 
				camaraG->matrix->matrix[9];	
				matrizaux->matrix[7] = 0.0;
	
	
				matrizaux->matrix[8] = 
				camaraG->matrix->matrix[2];	
				matrizaux->matrix[9] = 
				camaraG->matrix->matrix[6];
				matrizaux->matrix[10] = 
				camaraG->matrix->matrix[10];
				matrizaux->matrix[11] = 0.0;
				matrizaux->matrix[12] = 
				camaraG->posicionC.x;
        		matrizaux->matrix[13] = 
        		camaraG->posicionC.y;
        		matrizaux->matrix[14] = 
        		camaraG->posicionC.z;
				matrizaux->matrix[15] = 1.0;
				
				
        		glLoadIdentity();
        		glMatrixMode(GL_MODELVIEW);
        		glTranslatef(_selected_object-
        		>matrix->matrix[12],
		    		_selected_object->matrix->matrix[13],
		    		_selected_object->matrix->matrix[14]);
		     	glRotatef(angle,a,b,c);
        		glTranslatef(-_selected_object->
        		matrix->matrix[12],
		    		-_selected_object->matrix->matrix[13],
		    		-_selected_object->matrix->matrix[14]);
        		glMultMatrixd(matrizaux->matrix);     			       		
        		glMatrixMode(GL_MODELVIEW);
        		glGetDoublev
        		(GL_MODELVIEW_MATRIX,matrizaux
        		->matrix);
        		camaraG->posicionC.x = 
        		matrizaux->matrix[12];
        		camaraG->posicionC.y =
        		 matrizaux->matrix[13];
        		camaraG->posicionC.z = 
        		matrizaux->matrix[14];

				//Generamos la Mcsr a partir de la inversa
				camaraG->matrix->matrix[0] = 
				matrizaux->matrix[0];
				camaraG->matrix->matrix[1] = 
				matrizaux->matrix[4];
				camaraG->matrix->matrix[2] = 
				matrizaux->matrix[8];	
				camaraG->matrix->matrix[3] = 0.0;

	
				camaraG->matrix->matrix[4] = 
				matrizaux->matrix[1];
				camaraG->matrix->matrix[5] = 
				matrizaux->matrix[5];	
				camaraG->matrix->matrix[6] = 
				matrizaux->matrix[9];	
				camaraG->matrix->matrix[7] = 0.0;
	
	
				camaraG->matrix->matrix[8] = 
				matrizaux->matrix[2];	
				camaraG->matrix->matrix[9] = 
				matrizaux->matrix[6];
				camaraG->matrix->matrix[10] = 
				matrizaux->matrix[10];
				camaraG->matrix->matrix[11] = 0.0;
	
	
				camaraG->matrix->matrix[12] = 
				-((matrizaux->matrix[0]*matrizaux-
				>matrix[12])+
				(matrizaux->matrix[1]*matrizaux-
				>matrix[13]) + (matrizaux-
				>matrix[2]*matrizaux->matrix[14]));
				
				
				camaraG->matrix->matrix[13] = 
				-((matrizaux->matrix[4]*matrizaux
				->matrix[12])+(matrizaux-
				>matrix[5]*matrizaux->matrix[13]) + 
				(matrizaux->matrix[6]*matrizaux-
				>matrix[14]));
								
				camaraG->matrix->matrix[14] = -
				((matrizaux->matrix[8]*matrizaux-
				>matrix[12])+(matrizaux-
				>matrix[9]*matrizaux->matrix[13]) + 
				(matrizaux->matrix[10]*matrizaux-
				>matrix[14]));
				camaraG->matrix->matrix[15] = 1.0;

				glLoadMatrixd(camaraG->matrix->matrix);	
        		guardar_estado();
        		representar_matriz();
            }  
        }
    }
    else {
			(...)
    }
}

\end{lstlisting}
Hemos implementado la rotación en modo vuelo y modo análisis en la función rotate. Si el modo cámara está activado y el modoVuelo está activado, entonces la cámara rotará en el ángulo definido por angle en el vector definido por a,b,c.
\newline
Si nos encontramos en modo vuelo (modoV = 0), se realizará la siguiente operación:

\begin{lstlisting}
            	glMatrixMode(GL_MODELVIEW);
	            glLoadIdentity();
	            glRotatef(angle,a, b, c);
	            glMatrixMode(GL_MODELVIEW);
	            glMultMatrixd(camaraG->matrix->matrix);
	            guardar_estado();
	            representar_matriz();
\end{lstlisting}

Primero cargamos la matriz de identidad, y de esta forma "limpiamos" la matriz activa de openGL. Despues, aplicamos la matriz de rotación sobre esta matriz de identidad (la cámara rotará en un ángulo angle, en el vector definido por a, b y c).

Posteriormente, multiplicamos a la matriz activa de openGL la matriz de la cámara (también llamada la matriz de cambio de sistema de referencia).
Las dos siguientes líneas de código se encargan de guardar en la pila de matrices de la cámara el estado actual de la cámara y de representar la matriz en el terminal.
\newline

Si nos encontramos en modo análisis (modoV=1) la cámara rota inscribiendo una órbita alrededor del objeto seleccionado, por lo que dicho objeto siempre estará en el centro de la pantalla cuando este modo esté activado, y estaremos mirándolo en todo momento. El procedimiento para rotar cambia bastante respecto al método anterior:
\begin{lstlisting}

            	matrix_l *matrizaux;
        		matrizaux = (matrix_l *) malloc(sizeof (matrix_l));
        		

        		//Matriz inversa de la MCSR
        		matrizaux->matrix[0] = camaraG->matrix->matrix[0];
				matrizaux->matrix[1] = camaraG->matrix->matrix[4];
				matrizaux->matrix[2] = camaraG->matrix->matrix[8];	
				matrizaux->matrix[3] = 0.0;

	
				matrizaux->matrix[4] = camaraG->matrix->matrix[1];
				matrizaux->matrix[5] = camaraG->matrix->matrix[5];	
				matrizaux->matrix[6] = camaraG->matrix->matrix[9];	
				matrizaux->matrix[7] = 0.0;
	
	
				matrizaux->matrix[8] = camaraG->matrix->matrix[2];	
				matrizaux->matrix[9] = camaraG->matrix->matrix[6];
				matrizaux->matrix[10] = camaraG->matrix->matrix[10];
				matrizaux->matrix[11] = 0.0;
				matrizaux->matrix[12] = camaraG->posicionC.x;
        		matrizaux->matrix[13] = camaraG->posicionC.y;
        		matrizaux->matrix[14] = camaraG->posicionC.z;
				matrizaux->matrix[15] = 1.0;
				
				
        		glLoadIdentity();
        		glMatrixMode(GL_MODELVIEW);
        		glTranslatef(_selected_object->matrix->matrix[12],
		    		_selected_object->matrix->matrix[13],
		    		_selected_object->matrix->matrix[14]);
		     	glRotatef(angle,a,b,c);
        		glTranslatef(-_selected_object->matrix->matrix[12],
		    		-_selected_object->matrix->matrix[13],
		    		-_selected_object->matrix->matrix[14]);
        		glMultMatrixd(matrizaux->matrix);
     			
        		
        		glMatrixMode(GL_MODELVIEW);
        		glGetDoublev(GL_MODELVIEW_MATRIX,matrizaux->matrix);
        		camaraG->posicionC.x = matrizaux->matrix[12];
        		camaraG->posicionC.y = matrizaux->matrix[13];
        		camaraG->posicionC.z = matrizaux->matrix[14];

				//Generamos la Mcsr a partir de la inversa
				camaraG->matrix->matrix[0] = matrizaux->matrix[0];
				camaraG->matrix->matrix[1] = matrizaux->matrix[4];
				camaraG->matrix->matrix[2] = matrizaux->matrix[8];	
				camaraG->matrix->matrix[3] = 0.0;

	
				camaraG->matrix->matrix[4] = matrizaux->matrix[1];
				camaraG->matrix->matrix[5] = matrizaux->matrix[5];	
				camaraG->matrix->matrix[6] = matrizaux->matrix[9];	
				camaraG->matrix->matrix[7] = 0.0;
	
	
				camaraG->matrix->matrix[8] = matrizaux->matrix[2];	
				camaraG->matrix->matrix[9] = matrizaux->matrix[6];
				camaraG->matrix->matrix[10] = matrizaux->matrix[10];
				camaraG->matrix->matrix[11] = 0.0;
	
	
				camaraG->matrix->matrix[12] = -((matrizaux->matrix[0]*matrizaux->matrix[12])+(matrizaux->matrix[1]*matrizaux->matrix[13]) + (matrizaux->matrix[2]*matrizaux->matrix[14]));
				camaraG->matrix->matrix[13] = -((matrizaux->matrix[4]*matrizaux->matrix[12])+(matrizaux->matrix[5]*matrizaux->matrix[13]) + (matrizaux->matrix[6]*matrizaux->matrix[14]));				
				camaraG->matrix->matrix[14] = -((matrizaux->matrix[8]*matrizaux->matrix[12])+(matrizaux->matrix[9]*matrizaux->matrix[13]) + (matrizaux->matrix[10]*matrizaux->matrix[14]));
				camaraG->matrix->matrix[15] = 1.0;

				glLoadMatrixd(camaraG->matrix->matrix);	
        		guardar_estado();
        		representar_matriz();
\end{lstlisting}

Primero definimos una matriz auxiliar llamada matrizaux de tipo matrix\_l y le asignamos el espacio de memoria correspondiente al tamaño de su tipo de dato. Esta matriz será la encargada de modificar la posición a la matriz de la cámara.
Antes de continuar con la explicación, es necesario saber qué datos contiene la matriz de la cámara:

\[ \makegapedcells \begin{matrix*}   
  & \mathbf{Mcsr=}\begin{pmatrix} Xcx&Xcy&Xcz&-E*Xc \\ Ycx&Ycy&Ycz&-E*Yc \\ Zcx&Zcy&Zcz&-E*Zc \\ 0&0&0&1 \end{pmatrix}\\
\]


Xc, Yc, Zc, 0 define los ejes del sistema de referencia de la cámara en el sistema de referencia del mundo. Donde Xcx muestra a las coordenadas X de la cámara en el eje X del mundo, Ycx a las coordenadas X de la cámara en el eje Y del mundo, y Zcx a las coordenadas X de la cámara en el eje Z del mundo. La primera columna hace referencia a la X de la cámara, la segunda a la Y de la cámara, y la tercera a la Z de la cámara. La última fila se encarga de definir estos datos como coordenadas homogéneas. Si el valor de la última fila en una columna determinada es 0 entonces la columna es un vector, si es 1. entonces es un punto.\newline
La última columna, como podemos observar, es un producto escalar entre la posición de la cámara en el mundo y un número E que desconocemos.\newline
Para obtener la matriz que nos permita modificar la posición de la cámara, necesitamos obtener la matriz inversa de la cámara. Para rotar (y trasladar) la cámara en el modo vuelo nos vale con aplicar la función glTranslatef sobre la matriz de cambio de sistema de referencia, pero en este caso no nos vale. Necesitamos obtener la matriz inversa de la matriz de cambio de sistema de referencia, la cual contiene la posición de la cámara en su cuarta columna.\newline

Primero transmutamos los valores de las tres primeras columnas de la matriz de la cámara en la matriz auxiliar, es decir, los componentes de la i-ésima fila en la matriz de la cámara serán los componentes de la i-ésima columna en la matriz auxiliar \textit{matrizaux} (la que posteriormente será la matriz inversa de la matriz de la cámara. Después situamos la posición de la cámara en la cuarta columna de la matriz auxiliar.\newline
Posteriormente cargamos la matriz de identidad en la matriz activa de openGL. Realizamos un \textit{glTranslatef} a la posición del objeto, realizamos la rotación, y después volvemos a la posición original haciendo \textit{glTranslatef} a la posición negativa del objeto. Despúes de realizar estas operaciones, multiplicamos la matriz auxiliar a la matriz cargada en openGL.  
Esta nueva matriz es clave, porque ahora poseemos la posición actual de la cámara, y porque al invertirla como hemos hecho anteriormente, obtenemos la matriz de cambio de sistema de referencia completamente actualizada. Guardamos en \textit{matrizaux} mediante \textit{glGetDoublev} la matriz cargada en openGL, y procedemos a realizar exactamente el mismo proceso de inversión que hemos llevado a cabo antes. Sin embargo, como hemos visto, la matriz de cambio de sistema de referencia tenemos que colocar, en la i-ésima fila de la última columna el producto entre el vector de la i-ésima columna y la posición de la i-ésima fila en \textit{matrizaux}. Cabe mencionar que el valor de estos productos debe ser negativo.
Esta explicación puede ser visualizada mejor mediante el código que lo implementa.
\begin{lstlisting}
				camaraG->matrix->matrix[12] = -((matrizaux->matrix[0]*matrizaux->matrix[12])+(matrizaux->matrix[1]*matrizaux->matrix[13]) + (matrizaux->matrix[2]*matrizaux->matrix[14]));
				camaraG->matrix->matrix[13] = -((matrizaux->matrix[4]*matrizaux->matrix[12])+(matrizaux->matrix[5]*matrizaux->matrix[13]) + (matrizaux->matrix[6]*matrizaux->matrix[14]));				
				camaraG->matrix->matrix[14] = -((matrizaux->matrix[8]*matrizaux->matrix[12])+(matrizaux->matrix[9]*matrizaux->matrix[13]) + (matrizaux->matrix[10]*matrizaux->matrix[14]));
				camaraG->matrix->matrix[15] = 1.0;
\end{lstlisting}


Finalmente cargamos la matriz de cambio de sistema de referencia en la matriz activa de openGL.

\item \textbf{Traslación.}
La traslación, al igual que la rotación, puede llevarse a cabo tanto en modo vuelo como en modo análisis, y dependiendo del modo en el que estemos, se realizará de manera distinta.\newline

En el modo vuelo la traslación se realiza llevando a cabo un proceso homólogo al de la rotación, siguiendo el siguiente código:

\begin{lstlisting}
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
glTranslatef(a,b,c);

camaraG->posicionC.x += a;
camaraG->posicionC.y += b;
camaraG->posicionC.z += c;

glMatrixMode(GL_MODELVIEW);
glMultMatrixd(camaraG->matrix->matrix);
guardar_estado();
representar_matriz();
\end{lstlisting}
Primero definimos que la matriz activa sea el modelview. Después cargamos la matriz de identidad para "limpiar" la matriz activa de openGL. Posteriormente hacemos la traslación mediante la que movemos todos los elementos visibles por la cámara en la dirección y sentido declarados por el vector compuesto por los parámetros a,b,c. Cabe mencionar que los elementos no son trasladados en el sistema de referencia global (es decir, si tenemos un avión en el centro, y movemos la cámara a la derecha el avión no se moverá hacia la izquierda en el sistema de referencia global), si no en el sistema de referencia local de la cámara.\newline
Después mediante la función \textit{glMultMatrixd} multiplicamos a la matriz activa de openGL la matriz de cambio de sistema de referencia (o matriz de la cámara) mediante la cual hacemos efectiva la traslación de todos los puntos visibles por la cámara. Es decir, trasladamos los puntos visibles por la cámara, pero porque es la cámara la cual se mueve y no los puntos que ella ve.\newline
Como en cualquier transformación realizada sobre cualquier objeto, guardamos el estado mediante guardar\_estado() y representar\_matriz().
\newline

Al igual que en la rotación, en el modo análisis también se presentan severas diferencias respecto a la del modo vuelo.
\begin{lstlisting}
double distanciaZ=absoluto(-camaraG->posicionC.z - _selected_object->matrix->matrix[14]);

if(distanciaZ>c){
	glLoadIdentity();
	glTranslatef(a,b,c);
	camaraG->posicionC.z += c;
	glMatrixMode(GL_MODELVIEW);
	glMultMatrixd(camaraG->matrix->matrix);
	guardar_estado();
	representar_matriz();
}
else{
	printf("No nos podemos mover mas adelante\n");
	printf("DistanciaZ:%f <= Movimiento:%f\n",distanciaZ,c);
}
\end{lstlisting}
En primer lugar, cabe mencionar que únicamente nos trasladaremos en el eje \textit{z} cuando esté activado el modo análisis. La principal razón por la que esto es así es sencilla: el objeto a analizar \txtbf{SIEMPRE HA DE HALLARSE EN EL CENTRO DE LA CÁMARA}. Si nos pudiesemos desplazar en los ejes \textit{x} e \textit{y} esto ya no sería así.\newline
Cabe mencionar también que una función llamada \textit{absoluto} se ha realizado para que devuelva el valor absoluto del número introducido como parámetro de entrada.
\begin{lstlisting}
double absoluto(double a) {
	if(a>0) return a;
	else	return -a;
}
\end{lstlisting}
Comenzamos hallando el valor absoluto de la diferencia entre el valor negativo de la cámara en z y la componente z de la posición del objeto.
Si está diferencia no es mayor que el número de unidades en z en la que nos trasladamos cada vez que pulsamos \textit{GLUT_KEY_PAGE_UP}, ya no podremos avanzar más. Si la diferencia sí es mayor, primero cargaremos la matriz de identidad para "limpiar" la matriz activa de openGL y después usaremos glTranslatef para trasladar los puntos en el vector definido por a,b y c. Como hemos trasladado la cámara, actualizamos la variable camaraG \rightarrow posicionC.z aumentando su valor en c unidades. Posteriormente multiplicaremos a la matriz activada la matriz de cambio de sistema de referencia mediante \textit{glMultMatrixd}, para que los cambios se produzcan sobre el sistema de referencia de la cámara. Después guardamos el estado y representamos la matriz en el terminal.
\end{enumerate}


\item \textbf{Cambio de tipo de proyección.}

\end{enumerate}



\item \textbf{Inicializar correctamente los objetos.}\newline
Tras realizar los cambios necesarios para tener la pila de matrices deberemos de inicializar el objeto correctamente, tenemos que actualizarlo porque ahora tiene un nuevo parámetro, la lista de matrices llamada \textit{matrix}.\newline
Para ello, en el archivo 'load\_obj\_joseba.c' deberemos de crear una lista de matrices y asignarle un espacio de memoria a traves de la función 'malloc'.
\begin{lstlisting}
matrix_l *matrix;
...
matrix = (matrix_l *) malloc(sizeof (matrix_l));
\end{lstlisting}

Despues de asignarle el espacio de memoria correspondiente a un dato del tipo \textit{matrix\_l}, debemos de inicializar la lista de matrices de forma correcta, la matriz inicial será la matriz de identidad y apuntará a 0 porque al actuar como una pila no meteremos elementos por debajo de la misma. Para guardar la matriz de identidad vamos a cargarla en OpenGL a través de la función \textit{glLoadIdentity()} y luego vamos a obtener la matriz de identidad que acabamos de cargar y la vamos a guardar a través de la función \textit{glGetDoublev(GL\_MODELVIEW\_MATRIX, X)} que obtiene la matriz cargada en el \textit{GL\_MODELVIEW} y la guarda en la variable \textit{X}.\newline

\begin{lstlisting}
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
glGetDoublev(GL_MODELVIEW_MATRIX,matrix->matrix);
matrix->next=0;
\end{lstlisting}



\item \textbf{Crear/completar el teclado.}\newline
El teclado del que ya disponemos lee de forma incorrecta las flechas necesarias para realizar las transformaciones, por ello vamos a crear una función que lea esas teclas especiales. La función encargada de leerlas es 'void special\_keyboard(int key, int x, int y)', para que esta función las lea deberemos de especificarlo en el archivo 'main.c'. Esto lo hacemos a traves de la siguiente funcion:\textit{glutSpecialFunc(special\_keyboard)} que avisa que la función 'special\_keyboard' va a leer teclas especiales.\newline

Cabe destacar la existencia de las variables \textit{modo} y \textit{modo2}. La primera es la encargada de decidir si se quiere trasladar (modo=1), rotar (modo=2) o escalar (modo=3). La segunda por otro lado es la encargada de decir si se hacen los cambios respecto al mundo (modo2=1) o respecto al objeto (modo2=0), pero esta variable es usada en las funciones encargadas de realizar las transformaciones que se explicarán en el siguiente apartado.\newline
\begin{lstlisting}
void special_keyboard(int key, int x, int y) {
    switch(key) {
        case GLUT_KEY_F9:
            if(iluminacion==0) {
                printf("Usted acaba de activar el modo de iluminacion.\n");
                iluminacion=1;

                luces[0]=1; luces[1]=1;
                luces[2]=1; luces[3]=1;
                glEnable(GL_LIGHTING);
                glEnable(GL_LIGHT0);
                glEnable(GL_LIGHT1);
                glEnable(GL_LIGHT2);
                glEnable(GL_DEPTH_TEST);
            }
            else{
                iluminacion=0;
                glDisable(GL_LIGHTING);
                luces[0]=0; luces[1]=0;
                luces[2]=0; luces[3]=0;
            }
        break;

        case GLUT_KEY_F12:
            if(iluminacion==1) {
                iluminacion=2;
                printf("Usted acaba de activar el modo SMOOTH.\n");
                glShadeModel(GL_SMOOTH);
            }
            else{
                iluminacion=1;
                printf("Usted acaba de activar el modo FLAT.\n");
                glShadeModel(GL_FLAT);
            }
        break;

        case GLUT_KEY_F1:
            if(iluminacion!=0) {
                if(luces[0]==1) {
                    luces[0]=0;
                    printf("Se ha DESACTIVADO
                    la fuente de luz 1, el sol.\n");
                    glDisable(GL_LIGHT0);
                }
                else{
                    luces[0]=1;
                    printf("Se ha ACTIVADO
                    la fuente de luz 1, el sol.\n");
                    glEnable(GL_LIGHT0);
                }
            }
            else {
                printf("Activa la iluminacion
                para encender/apagar fuentes de luz.\n");
            }
        break;

        case GLUT_KEY_F2:
            if(iluminacion!=0) {
                if(luces[1]==1) {
                    luces[1]=0;
                    printf("Se ha DESACTIVADO
                    la fuente de luz 2, la bombilla.\n");
                    glDisable(GL_LIGHT1);
                }
                else{
                    luces[1]=1;
                    printf("Se ha ACTIVADO la
                    fuente de luz 2, la bombilla.\n");
                    glEnable(GL_LIGHT1);
                }
            }
            else {
                printf("Activa la iluminacion
                para encender/apagar fuentes de luz.\n");
            }
        break;

        case GLUT_KEY_F3:
            if(iluminacion!=0) {
                if(luces[2]==1) {
                    luces[2]=0;
                    printf("Se ha DESACTIVADO
                    la fuente de luz 3, el foco.\n");
                    glDisable(GL_LIGHT2);
                }
                else{
                    luces[2]=1;
                    printf("Se ha ACTIVADO
                    la fuente de luz 3, el foco.\n");
                    glEnable(GL_LIGHT2);
                }
            }
            else {
                printf("Activa la
                iluminacion para encender/apagar
                fuentes de luz.\n");
            }
        break;

        case GLUT_KEY_UP:
    		if(modoV==0) {//Modo Vuelo
	            if(modo==1) {
	                printf("Usted acaba de pulsar
	                Flecha Arriba con el modo de
	                Traslacion activado\n");
	                traslate(0,KG_STEP_MOVE,0);
	            }
	            if(modo==2) {
	                printf("Usted acaba de pulsar
	                Flecha Arriba con el modo de
	                Rotacion activado\n");
	                rotate(KG_STEP_CAMERA_ANGLE,KG_STEP_MOVE,
	                0, 0);
	            }
	            if(modo==3) {
	            	if(modog==0) {
	                	printf("Usted acaba de pulsar
	                	Flecha Arriba con el modo de
	                	Escalado activado\n");
	                	scale(1, KG_STEP_SCALE, 1);
	            	}
	            	if(modog==1) {
	            		printf("Usted acaba de pulsar
	            		Flecha Arriba, ha aumentado el
	            		volumen de visión en Y\n");
						camaraG->top=camaraG->top*1.1;
						camaraG->bottom=camaraG->bottom*1.1;
	            	}
	            }
        	}
        	else {//Rotacion especial modo analisis
        		printf("Modo Analisis activado,
        		solo se permite rotar con Flecha Arriba\n");
        		rotate(KG_STEP_CAMERA_ANGLE,camaraG->matrix-
        		>matrix[0],camaraG->matrix->matrix[4],
        		camaraG->matrix->matrix[8]);
        	}
        	printf("modog:%f\n",modog);
        	if (iluminacion!=0 && modog!=0 && modog!=1){
        		traslate(0,KG_STEP_MOVE,0);
        	}
            camera_update();
        break;

        case GLUT_KEY_DOWN:
        	if(modoV==0) {//Modo Vuelo
	            if(modo==1) {
	                printf("Usted acaba de pulsar Flecha Abajo con el modo de Traslacion activado\n");
	                traslate(0,-KG_STEP_MOVE,0);
	            }
	            if(modo==2) {
	                printf("Usted acaba de pulsar
	                Flecha Abajo con el modo de
	                Rotacion activado\n");
	                rotate(KG_STEP_CAMERA_ANGLE,-KG_STEP_MOVE,
	                 0, 0);
	            }
	            if(modo==3) {
	            	if (modog==0)
	            	{
	            		printf("Usted acaba de pulsar
	            		Flecha Abajo con el modo de
	            		Escalado activado\n");
	                	scale(1, 1/KG_STEP_SCALE, 1);
	            	}
	            	if (modog==1) {
	            		printf("Usted acaba de pulsar
	            		Flecha Abajo, ha reducido el
	            		volumen de visión en Y\n");
                		camaraG->bottom=camaraG->bottom*0.9;
                		camaraG->top=camaraG->top*0.9;
	            	}
	           	}
	           }
           else {//Rotacion especial modo analisis
    			printf("Modo Analisis activado, solo se permite rotar con Flecha Abajo\n");
    			rotate(KG_STEP_CAMERA_ANGLE,-camaraG->matrix->matrix[0],-camaraG->matrix->matrix[4],-camaraG->matrix->matrix[8]);
    		}
    		printf("modog:%f\n",modog);
    		if (iluminacion!=0 && modog!=0 && modog!=1){
        		traslate(0,-KG_STEP_MOVE,0);
        	}
	           	camera_update();
        break;

        case GLUT_KEY_LEFT:
        	if(modoV==0) {//Modo Vuelo
	            if(modo==1) {
	                printf("Usted acaba de pulsar
	                Flecha Izquierda con el modo de
	                Traslacion activado\n");
	                traslate(-KG_STEP_MOVE,0,0);
	            }
	            if(modo==2) {
	                printf("Usted acaba de pulsar Flecha Izquierda con el modo de Rotacion activado\n");
	                rotate(KG_STEP_CAMERA_ANGLE,0,
	                -KG_STEP_MOVE, 0);
	            }

	            if(modo==3) {
	            	if(modog==0) {
	                	printf("Usted acaba de pulsar
	                	Flecha Izquierda con el modo de
	                	Escalado activado\n");
	                	scale(1/KG_STEP_SCALE,1, 1);
	                }
	                if(modog==1) {
	                	printf("Usted acaba de pulsar
	                	Flecha Izquierda, ha reducido el
	                	volumen de visión en X\n");
                		camaraG->left=camaraG->left*0.9;
                		camaraG->right=camaraG->right*0.9;
	                }
	            }
	        }
	        else {//Rotacion especial modo analisis
        		printf("SIN IMPLEMENTAR\n");
        		rotate(KG_STEP_CAMERA_ANGLE,-camaraG->matrix
        		->matrix[1],-camaraG->matrix->matrix[5],
        		-camaraG->matrix->matrix[9]);
        	}
        	printf("modog:%f\n",modog);
        	if (iluminacion!=0 && modog!=0 && modog!=1){
        		traslate(-KG_STEP_MOVE,0,0);
        	}
	            camera_update();
        break;

        case GLUT_KEY_RIGHT:
        	if(modoV == 0){
                if(modo==1) {
                    printf("Usted acaba de pulsar Flecha Derecha
                    con el modo de Traslacion activado\n");
                    traslate(KG_STEP_MOVE,0,0);
                }
                if(modo==2) {
                    printf("Usted acaba de pulsar
                    Flecha Derecha con el modo de Rotacion
                    activado\n");
                    rotate(KG_STEP_CAMERA_ANGLE, 0,
                     KG_STEP_MOVE, 0);
                }
                if(modo==3) {
                	if(modog==0) {
                    	printf("Usted acaba de pulsar
                    	Flecha Derecha con el modo de
                    	Escalado activado\n");
                    	scale(KG_STEP_SCALE,1, 1);
                	}
                	if(modog==1) {
                		printf("Usted acaba de
                		pulsar Felcha Derecha, ha
                		aumentado el volumen de visión
                		en X\n");
                		camaraG->right=camaraG->right*1.1;
                		camaraG->left=camaraG->left*1.1;
                	}
                }
              }
            else{
              	rotate(KG_STEP_CAMERA_ANGLE,
              	camaraG-> matrix->matrix[1],
              	camaraG->matrix->matrix[5],
              	camaraG->matrix->matrix[9]);
            }
            printf("modog:%f\n",modog);  
            if (iluminacion!=0 && modog!=0 && modog!=1){
        		traslate(KG_STEP_MOVE,0,0);
        	} 
            camera_update();
        break;

        case GLUT_KEY_PAGE_UP:
        	if(modoV == 0){//Modo vuelo
                if(modo==1) {
                    printf("Usted acaba de pulsar
                    PagUp con el modo de Traslacion
                    activado\n");
                    traslate(0, 0, KG_STEP_MOVE);
                }
                if(modo==2) {
                    printf("Usted acaba de pulsar 
                    PagUp con el modo de Rotacion activado\n");
                    rotate(KG_STEP_CAMERA_ANGLE, 0, 0,
                     KG_STEP_MOVE);
                }
               	if(modo==3) {
               		if(modog==0){
                    	printf("Usted acaba de pulsar
                    	PagUp con el modo de Escalado
                    	activado\n");
                    	scale(1, 1, KG_STEP_SCALE);
                    }
                    if (modog==1){
                     	printf("Usted acaba de
                     	pulsar PagUp, ha aumentado
                     	la distancia de visión\n");
                		camaraG->near=camaraG->near*1.1;
                		camaraG->far=camaraG->far*1.1;
                     } 
                }
             }
            else {//Modo analisis
             	if(modo==2){
             		rotate(KG_STEP_CAMERA_ANGLE,
             		camaraG->matrix->matrix[2],
             		camaraG->matrix->matrix[6],
             		camaraG->matrix->matrix[10]);
             	}
             	if(modo==1){
             		traslate(0,0,KG_STEP_MOVE);
             	}
            }
            printf("modog:%f\n",modog);
            if (iluminacion!=0 && modog!=0 && modog!=1){
        		traslate(0, 0, KG_STEP_MOVE);
        	}

                camera_update();
        break;

        case GLUT_KEY_PAGE_DOWN:
        	if(modoV == 0){
        		if(modo==1) {
                    printf("Usted acaba de pulsar PagDown
                    con el modo de Traslacion activado\n");
                    traslate(0,0,-KG_STEP_MOVE);
                }
               	if(modo==2) {
                    printf("Usted acaba de pulsar PagDown
                    con el modo de Rotacion activado\n");
                    rotate(KG_STEP_CAMERA_ANGLE, 0, 0, 
                    -KG_STEP_MOVE);
                }
                if(modo==3) {
                	if(modog==0) {
                    	printf("Usted acaba de pulsar
                    	PagDown con el modo de Escalado
                    	activado\n");
                    	scale(1, 1, 1/KG_STEP_SCALE);
                	}
                	if(modog==1) {
                		printf("Usted acaba de pulsar PagUp,
                		 ha reducido la distancia de visión\n");
                		camaraG->near=camaraG->near*0.9;
                		camaraG->far=camaraG->far*0.9;
                	}
                }
            }
            else {
            	if(modo==2){
             		rotate(KG_STEP_CAMERA_ANGLE,-camaraG-
             		>matrix->matrix[2],-camaraG->matrix
             		->matrix[6],-camaraG->matrix->matrix[10]);
             	}
             	if(modo==1){
             		traslate(0,0,-KG_STEP_MOVE);
             	}
            }
            printf("modog:%f\n",modog);
            if (iluminacion!=0 && modog!=0 && modog!=1){
        		traslate(0,0,-KG_STEP_MOVE);
        	}
            camera_update();
        break;
        
    }
    
    glutPostRedisplay();
}

\end{lstlisting}

En la función de teclado normal simplemente hemos hecho que lea las teclas que el enunciado menciona, cambiando los valores de 'modo' y 'modo2' de forma correspondiente y imprimiendo la acción que realiza la tecla que se acaba de pulsar.\newline
Cabe destacar la existencia de la función 'deshacer()', usada a la hora de pulsar \textit{control + z}, esta es la función encargada de deshacer un cambio volviendo a la matriz de estado anterior, esta función será explicada en el siguiente apartado.

\begin{lstlisting}
void keyboard(unsigned char key, int x, int y) {
    ...
    ...
    ...
    case 'g':
    case 'G':
        printf("Usted acaba de activar el sistema de 
        referencia al del mundo\n");
        modo2=1;
        break;
    break;
    case 'l':
    case 'L':
        printf("Usted acaba de activar el sistema de 
        referencia al del objeto\n");
        modo2=0;
        break;
    break;

    case 'b':
    case 'B':
        printf("Usted acaba de activar el modo de rotacion\n");
        modo=2;
        break;
    break;

    case 't':
    case 'T':
        printf("Usted acaba de activar el modo de escalado\n");
        modo=3;
        break;
    break;

    case 'm':
    case 'M':
        printf("Usted acaba de activar el modo de traslacion\n");
        modo=1;
        break;
    break;

    case 26: //Control + z Tenemos que volver al estado anterior
        printf("Deshacer cambios\n");
        deshacer();
    break;
    ...
    ...
    ...
}

\end{lstlisting}





\item \textbf{Crear las funciones necesarias para las transformaciones.}\newline
En este apartado vamos a explicar las funciones que hemos creado para el correcto funcionamiento de las transformaciones. Tenemos que realizar tres transformaciones, escalado, traslación y rotación. Estos cambios serán realizados a traves de matrices de transformación, es importante saber que las operaciones con matrices no cumplen la propiedad distributiva (excepto las operaciones con la matriz de identidad) de manera que no es lo mismo 'A*B' que 'B*A'. Esto es algo importante, ya que si multiplicamos nuestra matriz de estado actual por la nueva matriz de cambios por la izquierda, realizaremos el cambio respecto al objeto y si lo multiplicamos por la derecha realizaremos el cambio respecto al mundo.\newline

Para realizar el \textbf{cambio respecto al objeto}, basta con cargar la matriz de estado actual, usar la función correspondiente (\textit{glTraslatef(float a, float b, float c)}, \textit{glScalef(float a, float b, float c)} o \textit{glRotatef(float angle,float a, float b, float c)}) y guardar la nueva matriz en la pila a través de la función 'guardar\_estado()' que hemos creado.\newline

Por otro lado, para realizar los \textbf{cambios respecto al mundo} deberemos de conseguir multiplicar por la derecha. Esto lo vamos a conseguir cargando primero la matriz de identidad, operando sobre ella con la función correspondiente (scale(float a, float b, float c), rotate(float angle,float a, float b, float c) o traslate(float a, float b, float c)), y multiplicando la matriz de estado actual de la pila por la matriz cargada, esto lo haremos a traves de la función 'glMultMatrixd(double *m)', donde 'm' es la matriz correspondiente al estado actual del objeto, tras esto guardamos el cambio realizado con la función 'guardar\_estado()'.\newline
Cabe destacar que si no hay un objeto seleccionado (esto solo es posible si no hay objetos cargados) el programa nos avisará de ello y no realizará ninguna transformacion, ya que de lo contrario nos daría un error de segmentación.\newline


\begin{lstlisting}

void traslate(float a, float b, float c)
{
    if(_selected_object!=NULL) {
        if(modog==0) {//Hacemos el cambio respecto al objeto
            if(modo2==0){
                printf("Traslacion respecto al objeto\n");
                glMatrixMode(GL_MODELVIEW);
                glLoadMatrixd(_selected_object->matrix->matrix);
                glTranslatef(a, b, c);
                guardar_estado();
                representar_matriz();
            }
            else {//Hacemos el cambio respecto al mundo
                printf("Traslacion respecto al mundo\n");
                glMatrixMode(GL_MODELVIEW);
                glLoadIdentity();
                glTranslatef(a, b, c);
                glMatrixMode(GL_MODELVIEW);
                glMultMatrixd(_selected_object->matrix->matrix);
                guardar_estado();
                representar_matriz();
                }
        }
        //Cambio respecto a la camara
        else {
        	if (modoV==0)//Modo vuelo
            {
	            glMatrixMode(GL_MODELVIEW);
	            glLoadIdentity();
	            glTranslatef(a,b,c);
	            printf("Posicion de la camara X %f Y %f Z %f\n",camaraG->posicionC.x,camaraG->posicionC.y,camaraG->posicionC.z);
	            camaraG->posicionC.x += a;
	            camaraG->posicionC.y += b;
	            camaraG->posicionC.z += c;
	            printf("Posicion NUEVA de la camara X %f Y %f Z %f\n",camaraG->posicionC.x,camaraG->posicionC.y,camaraG->posicionC.z);
	            glMatrixMode(GL_MODELVIEW);
	            glMultMatrixd(camaraG->matrix->matrix);
	            guardar_estado();
	            representar_matriz();
	        }
	        else {//Modo analisis, movernos hacia adelante o hacia atras
	        	printf("posicionC.z:%f Z objeto:%f\n",camaraG->posicionC.z,_selected_object->matrix->matrix[14]);
	        	double distanciaZ=absoluto(-camaraG->posicionC.z - _selected_object->matrix->matrix[14]);
	        	printf("DistanciaZ:%f\n",distanciaZ);
	        	if(distanciaZ>c) {
	        		glLoadIdentity();
		            glTranslatef(a,b,c);
		            camaraG->posicionC.z += c;
		            glMatrixMode(GL_MODELVIEW);
		            glMultMatrixd(camaraG->matrix->matrix);
		            guardar_estado();
		            printf("CamaraG->posicionC.z:%f\n",camaraG->posicionC.z);
		            representar_matriz();
	        	}
	        	else{
	        		printf("No nos podemos mover mas adelante\n");
	        		printf("DistanciaZ:%f <= Movimiento:%f\n",distanciaZ,c);
	        	}
	        }
        }
        if (iluminacion!=0)
        {
        	printf("Trasladamos la bombilla\n");
        	pbombilla[0]+=a;
        	pbombilla[1]+=b;
        	pbombilla[2]+=c;
        	glLightfv(GL_LIGHT1, GL_POSITION, pbombilla);
        	printf("Posicion bombilla: X:%f Y:%f Z:%f\n",pbombilla[0],pbombilla[1],pbombilla[2]);
        }
    }
    else {
        printf("ERROR: No hay ningun objeto cargado!\n");
    }      
}

void scale(float a, float b, float c)
{
    if(_selected_object!=NULL) {
        if(modog==0) {
            //Hacemos el cambio respecto al objeto
            if(modo2==0){
                printf("Escalado respecto al objeto\n");
                glMatrixMode(GL_MODELVIEW);
                glLoadMatrixd(_selected_object->matrix->matrix);
                glScalef(a, b, c);
                guardar_estado();
                representar_matriz();
            }
            //Hacemos el cambio respecto al mundo
            else {
                printf("Escalado respecto al mundo\n");
                glMatrixMode(GL_MODELVIEW);
                glLoadIdentity();
                glScalef(a, b, c);
                glMatrixMode(GL_MODELVIEW);
                glMultMatrixd(_selected_object->matrix->matrix);
                guardar_estado();
                representar_matriz();
            }
        }
        else {//Cambio respecto a la camara
            glMatrixMode(GL_MODELVIEW);
            glLoadIdentity();
            glScalef(a, b, c);
            glMatrixMode(GL_MODELVIEW);
            glMultMatrixd(camaraG->matrix->matrix);
            guardar_estado();
            representar_matriz();
        }
    }
    else {
        printf("ERROR: No hay ningun objeto cargado!\n");
    }
}


void rotate(float angle,float a, float b, float c)
{
    if(_selected_object!=NULL) {
        if(modog==0) {//Sobre el objeto
            if(modo2==0){
                printf("Rotacion respecto al objeto\n");
                glMatrixMode(GL_MODELVIEW);
                glLoadMatrixd(_selected_object->matrix->matrix);
                glRotatef(angle,a, b, c);
                guardar_estado();
                representar_matriz();
            }
            else {
                printf("Rotacion respecto al mundo\n");
                glMatrixMode(GL_MODELVIEW);
                glLoadIdentity();
                glRotatef(angle,a, b, c);
                glMatrixMode(GL_MODELVIEW);
                glMultMatrixd(_selected_object->matrix->matrix);
                guardar_estado();
                representar_matriz();
            }   
        }
        else {
            if (modoV==0)//Modo vuelo
            {
            	glMatrixMode(GL_MODELVIEW);
	            glLoadIdentity();
	            glRotatef(angle,a, b, c);
	            glMatrixMode(GL_MODELVIEW);
	            glMultMatrixd(camaraG->matrix->matrix);
	            guardar_estado();
	            representar_matriz();
            }
            else{//modo analisis
            	printf("ROTACION RESPECTO AL OBJETO???\n");
            	matrix_l *matrizaux;
        		matrizaux = (matrix_l *) malloc(sizeof (matrix_l));
        		
        		printf("Posicion de la camara\n");
        		printf("Posicion de la camara X %f Y %f Z %f\n",camaraG->posicionC.x,camaraG->posicionC.y,camaraG->posicionC.z);
        		//Matriz inversa de la MCSR
        		matrizaux->matrix[0] = camaraG->matrix->matrix[0];
				matrizaux->matrix[1] = camaraG->matrix->matrix[4];
				matrizaux->matrix[2] = camaraG->matrix->matrix[8];	
				matrizaux->matrix[3] = 0.0;

	
				matrizaux->matrix[4] = camaraG->matrix->matrix[1];
				matrizaux->matrix[5] = camaraG->matrix->matrix[5];	
				matrizaux->matrix[6] = camaraG->matrix->matrix[9];	
				matrizaux->matrix[7] = 0.0;
	
	
				matrizaux->matrix[8] = camaraG->matrix->matrix[2];	
				matrizaux->matrix[9] = camaraG->matrix->matrix[6];
				matrizaux->matrix[10] = camaraG->matrix->matrix[10];
				matrizaux->matrix[11] = 0.0;
				matrizaux->matrix[12] = camaraG->posicionC.x;
        		matrizaux->matrix[13] = camaraG->posicionC.y;
        		matrizaux->matrix[14] = camaraG->posicionC.z;
				matrizaux->matrix[15] = 1.0;
				
				
        		glLoadIdentity();
        		glMatrixMode(GL_MODELVIEW);
        		glTranslatef(_selected_object->matrix->matrix[12],
		    		_selected_object->matrix->matrix[13],
		    		_selected_object->matrix->matrix[14]);
		     	glRotatef(angle,a,b,c);
        		glTranslatef(-_selected_object->matrix->matrix[12],
		    		-_selected_object->matrix->matrix[13],
		    		-_selected_object->matrix->matrix[14]);
        		glMultMatrixd(matrizaux->matrix);
		    
        		

        		
        		
        		glMatrixMode(GL_MODELVIEW);
        		glGetDoublev(GL_MODELVIEW_MATRIX,matrizaux->matrix);
        		camaraG->posicionC.x = matrizaux->matrix[12];
        		camaraG->posicionC.y = matrizaux->matrix[13];
        		camaraG->posicionC.z = matrizaux->matrix[14];

				//Generamos la Mcsr a partir de la inversa
				camaraG->matrix->matrix[0] = matrizaux->matrix[0];
				camaraG->matrix->matrix[1] = matrizaux->matrix[4];
				camaraG->matrix->matrix[2] = matrizaux->matrix[8];	
				camaraG->matrix->matrix[3] = 0.0;

	
				camaraG->matrix->matrix[4] = matrizaux->matrix[1];
				camaraG->matrix->matrix[5] = matrizaux->matrix[5];	
				camaraG->matrix->matrix[6] = matrizaux->matrix[9];	
				camaraG->matrix->matrix[7] = 0.0;
	
	
				camaraG->matrix->matrix[8] = matrizaux->matrix[2];	
				camaraG->matrix->matrix[9] = matrizaux->matrix[6];
				camaraG->matrix->matrix[10] = matrizaux->matrix[10];
				camaraG->matrix->matrix[11] = 0.0;
	
	
				camaraG->matrix->matrix[12] = -((matrizaux->matrix[0]*matrizaux->matrix[12])+(matrizaux->matrix[1]*matrizaux->matrix[13]) + (matrizaux->matrix[2]*matrizaux->matrix[14]));
				camaraG->matrix->matrix[13] = -((matrizaux->matrix[4]*matrizaux->matrix[12])+(matrizaux->matrix[5]*matrizaux->matrix[13]) + (matrizaux->matrix[6]*matrizaux->matrix[14]));				
				camaraG->matrix->matrix[14] = -((matrizaux->matrix[8]*matrizaux->matrix[12])+(matrizaux->matrix[9]*matrizaux->matrix[13]) + (matrizaux->matrix[10]*matrizaux->matrix[14]));
				camaraG->matrix->matrix[15] = 1.0;

				glLoadMatrixd(camaraG->matrix->matrix);	
        		guardar_estado();
        		representar_matriz();
            }  
        }
    }
    else {
        printf("ERROR: No hay ningun objeto cargado!\n");
    }
}



\end{lstlisting}


Para guardar los cambios realizados en el objeto usaremos la funcion \textbf{'guardar\_estado()'}. Simplemente creamos una nueva lista auxiliar de matrices y le asignamos un espacio de memoria a través de un malloc. Luego hacemos que apunte a la matriz actual y guardamos la matriz cargada en estos momentos (a través de la función glGetDoublev()) en la auxiliar. Finalmente asignamos esta nueva lista a la del objeto seleccionado y ya habriamos terminado.\newline

\begin{lstlisting}
void guardar_estado()
{
    matrix_l *matrizaux;
    matrizaux = (matrix_l *) malloc(sizeof (matrix_l));
    matrizaux->next=_selected_object->matrix;
    glGetDoublev(GL_MODELVIEW_MATRIX,matrizaux->matrix);
    _selected_object->matrix=matrizaux;   
}
\end{lstlisting}


Para \textbf{deshacer un cambio} vamos a crear una lista auxiliar de matrices, 'borrar', que vamos a igualar a la lista del objeto seleccionado. Tras esto vamos a hacer que el objeto seleccionado apunte a la siguiente matriz de la lista y luego borraremos la matriz auxiliar creada para que no ocupe espacio de memoria de forma innecesaria.\newline
Cabe destacar que no se realizarán cambios si no hay un objeto seleccionado o si hemos vuelto a la matriz de estado inicial, sabremos que es la matriz de estado inicial porque su puntero apuntará a un '0' ya que asi hemos decidido que se inicialicen los objetos anteriormente.\newline

\begin{lstlisting}
void deshacer() {
    if(_selected_object!=NULL) {
		if(_selected_object->matrix->next!=0) {
			glMatrixMode(GL_MODELVIEW);
			matrix_l *borrar = _selected_object->matrix;
			_selected_object->matrix=_selected_object->matrix->next;
			free(borrar);
			glLoadMatrixd(_selected_object->matrix->matrix);
		}
		else {
			printf("ERROR: El objeto no tiene mas estados anteriores\n");
		}
	}
    else {
        printf("ERROR: No hay ningun objeto cargado!\n");
    }
}
\end{lstlisting}
\end{enumerate}
\end{document}
